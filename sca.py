
"""sca.py
Sine Cosine Algorithm implementation (vectorized & documented)
Author: Generated by ChatGPT (for student project)
License: MIT
"""

import numpy as np
from typing import Callable, Tuple, Dict, Any

def sphere(x: np.ndarray) -> float:
    """Sphere benchmark function."""
    return float(np.sum(x**2))

class SCA:
    """Sine Cosine Algorithm (SCA) implementation.

    Parameters
    ----------
    obj_func : Callable[[np.ndarray], float]
        Objective function to minimize.
    dim : int
        Dimensionality of the problem.
    bounds : Tuple[np.ndarray, np.ndarray]
        Lower and upper bounds as two arrays of size dim.
    pop_size : int
        Population size.
    max_iter : int
        Maximum number of iterations.
    seed : int | None
        Random seed for reproducibility.
    """

    def __init__(self, obj_func: Callable[[np.ndarray], float],
                 dim: int,
                 bounds: Tuple[np.ndarray, np.ndarray],
                 pop_size: int = 30,
                 max_iter: int = 500,
                 seed: int = None):
        self.obj_func = obj_func
        self.dim = int(dim)
        self.bounds = (np.array(bounds[0], dtype=float), np.array(bounds[1], dtype=float))
        self.pop_size = int(pop_size)
        self.max_iter = int(max_iter)
        self.rng = np.random.default_rng(seed)

        # initialize population uniformly in bounds
        lb, ub = self.bounds
        self.population = lb + (ub - lb) * self.rng.random((self.pop_size, self.dim))
        self.fitness = np.full(self.pop_size, np.inf)
        self.best_idx = None
        self.best_pos = None
        self.best_fit = np.inf

    def _ensure_bounds(self, x: np.ndarray) -> np.ndarray:
        lb, ub = self.bounds
        return np.minimum(np.maximum(x, lb), ub)

    def evaluate(self) -> None:
        """Evaluate fitness for entire population and update global best."""
        for i in range(self.pop_size):
            self.fitness[i] = self.obj_func(self.population[i])
            if self.fitness[i] < self.best_fit:
                self.best_fit = self.fitness[i]
                self.best_pos = self.population[i].copy()
                self.best_idx = i

    def run(self, verbose: bool = False) -> Dict[str, Any]:
        """Run the SCA optimization and return results dictionary."""
        convergence = []
        # initial evaluation
        self.evaluate()
        convergence.append(self.best_fit)

        for t in range(1, self.max_iter + 1):
            # r1 decreases linearly from 2 to 0 (typical choice)
            r1 = 2 - t * (2 / self.max_iter)
            for i in range(self.pop_size):
                # random coefficients
                r2 = 2 * np.pi * self.rng.random(self.dim)   # angle
                r3 = self.rng.random(self.dim)               # distance control
                r4 = self.rng.random(self.dim)               # switch between sine/cosine

                # compute distance component
                distance = np.abs(r3 * self.best_pos - self.population[i])

                # sine update where r4 < 0.5 else cosine update
                mask = r4 < 0.5
                # update using vectorized expression
                sin_term = r1 * np.sin(r2) * distance
                cos_term = r1 * np.cos(r2) * distance
                new_pos = np.where(mask, self.population[i] + sin_term, self.population[i] + cos_term)

                # ensure bounds and assign
                self.population[i] = self._ensure_bounds(new_pos)

            # evaluate after updates
            self.evaluate()
            convergence.append(self.best_fit)
            if verbose and (t % max(1, self.max_iter//10) == 0):
                print(f"Iteration {t}/{self.max_iter} - best fitness: {self.best_fit:.6e}")

        return {
            'best_pos': self.best_pos,
            'best_fit': float(self.best_fit),
            'convergence': np.array(convergence)
        }

if __name__ == '__main__':
    # Quick test run on Sphere
    import matplotlib.pyplot as plt
    obj = sphere
    dim = 10
    bounds = (-5.12 * np.ones(dim), 5.12 * np.ones(dim))
    sca = SCA(obj, dim, bounds, pop_size=50, max_iter=200, seed=42)
    res = sca.run(verbose=True)
    print('Best fitness:', res['best_fit'])
    # plot convergence
    plt.plot(res['convergence'])
    plt.yscale('log')
    plt.xlabel('Iteration')
    plt.ylabel('Best fitness (log scale)')
    plt.title('SCA Convergence on Sphere (demo)')
    plt.grid(True)
    plt.tight_layout()
    plt.savefig('sca_convergence_demo.png', dpi=150)
    print('Saved plot sca_convergence_demo.png')
